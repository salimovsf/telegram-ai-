<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegram Knowledge Base</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .main-content {
            padding: 40px;
        }
        
        .upload-section {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-section:hover {
            border-color: #764ba2;
            background: #f8f9ff;
        }
        
        .upload-section.dragover {
            border-color: #4CAF50;
            background: #f0fff0;
        }
        
        .upload-icon {
            font-size: 4rem;
            color: #667eea;
            margin-bottom: 20px;
        }
        
        .upload-text {
            font-size: 1.3rem;
            color: #666;
            margin-bottom: 20px;
        }
        
        .file-input {
            display: none;
        }
        
        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        
        .upload-btn:hover {
            transform: translateY(-2px);
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
            display: none;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .status {
            text-align: center;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            display: none;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f1b0b7;
        }
        
        .status.processing {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .controls {
            display: none;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
        }
        
        .control-card {
            background: #f8f9ff;
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            transition: transform 0.2s ease;
            cursor: pointer;
        }
        
        .control-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        
        .control-card h3 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .search-section {
            display: none;
            margin: 30px 0;
        }
        
        .search-input {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid #e0e0e0;
            border-radius: 25px;
            font-size: 1.1rem;
            outline: none;
            transition: border-color 0.3s ease;
        }
        
        .search-input:focus {
            border-color: #667eea;
        }
        
        .search-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            margin-left: 10px;
            cursor: pointer;
            font-size: 1.1rem;
        }
        
        .results {
            margin-top: 30px;
        }
        
        .result-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .result-date {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        
        .result-text {
            line-height: 1.6;
        }
        
        .stats {
            display: none;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }
        
        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .main-content {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üì± Telegram Knowledge Base</h1>
            <p>–ü—Ä–µ–≤—Ä–∞—Ç–∏—Ç–µ –≤–∞—à —ç–∫—Å–ø–æ—Ä—Ç Telegram –≤ —É–º–Ω—É—é –±–∞–∑—É –∑–Ω–∞–Ω–∏–π</p>
        </div>
        
        <div class="main-content">
            <!-- Upload Section -->
            <div class="upload-section" id="uploadSection">
                <div class="upload-icon">üìÅ</div>
                <div class="upload-text">
                    –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ JSON —Ñ–∞–π–ª —ç–∫—Å–ø–æ—Ä—Ç–∞ Telegram —Å—é–¥–∞<br>
                    –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ñ–∞–π–ª–∞
                </div>
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    –í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª
                </button>
                <input type="file" id="fileInput" class="file-input" accept=".json" onchange="handleFileSelect(event)">
            </div>
            
            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            
            <div class="status" id="status"></div>
            
            <!-- Stats -->
            <div class="stats" id="stats">
                <div class="stat-card">
                    <div class="stat-number" id="messageCount">0</div>
                    <div class="stat-label">–°–æ–æ–±—â–µ–Ω–∏–π</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="chunkCount">0</div>
                    <div class="stat-label">–ë–ª–æ–∫–æ–≤</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="topicCount">0</div>
                    <div class="stat-label">–¢–µ–º</div>
                </div>
            </div>
            
            <!-- Controls -->
            <div class="controls" id="controls">
                <div class="control-card" onclick="showSearch()">
                    <h3>üîç –ü–æ–∏—Å–∫</h3>
                    <p>–ù–∞–π—Ç–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ –∑–∞–ø—Ä–æ—Å—É</p>
                </div>
                <div class="control-card" onclick="generateGuide()">
                    <h3>üìñ –ì–∞–π–¥</h3>
                    <p>–°–æ–∑–¥–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥–∞–π–¥</p>
                </div>
            </div>
            
            <!-- Search Section -->
            <div class="search-section" id="searchSection">
                <div style="display: flex; align-items: center; margin-bottom: 20px;">
                    <input type="text" id="searchInput" class="search-input" placeholder="–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å..." onkeypress="handleSearchKeyPress(event)">
                    <button class="search-btn" onclick="performSearch()">–ù–∞–π—Ç–∏</button>
                </div>
                <div id="searchResults" class="results"></div>
            </div>
        </div>
    </div>

    <script>
        let processedData = null;
        let chunks = [];
        let embeddings = null;
        
        // File handling
        const uploadSection = document.getElementById('uploadSection');
        const fileInput = document.getElementById('fileInput');
        
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });
        
        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });
        
        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });
        
        uploadSection.addEventListener('click', () => {
            fileInput.click();
        });
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                handleFile(file);
            }
        }
        
        async function handleFile(file) {
            if (!file.name.endsWith('.json')) {
                showStatus('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ JSON —Ñ–∞–π–ª', 'error');
                return;
            }
            
            if (file.size > 500 * 1024 * 1024) { // 500MB limit for demo
                showStatus('–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π. –ú–∞–∫—Å–∏–º—É–º 500MB –¥–ª—è –¥–µ–º–æ-–≤–µ—Ä—Å–∏–∏', 'error');
                return;
            }
            
            showStatus('–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–∞...', 'processing');
            showProgress(0);
            
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                
                showProgress(25);
                await processData(data);
                
                showProgress(100);
                showStatus('‚úÖ –§–∞–π–ª —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω!', 'success');
                
                document.getElementById('controls').style.display = 'grid';
                document.getElementById('stats').style.display = 'grid';
                
            } catch (error) {
                console.error('Error processing file:', error);
                showStatus('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∞–π–ª–∞: ' + error.message, 'error');
            }
        }
        
        async function processData(data) {
            const messages = data.messages || data;
            const cleanedMessages = [];
            
            showProgress(30);
            
            // Clean messages
            for (let i = 0; i < messages.length; i++) {
                const msg = messages[i];
                const text = extractText(msg.text);
                
                if (text && text.length > 10 && !isOnlyEmoji(text)) {
                    cleanedMessages.push({
                        date: msg.date || '',
                        author: msg.from || msg.from_id || '',
                        text: text
                    });
                }
                
                if (i % 1000 === 0) {
                    showProgress(30 + (i / messages.length) * 30);
                    await sleep(1); // Allow UI to update
                }
            }
            
            showProgress(60);
            
            // Create chunks
            chunks = createChunks(cleanedMessages);
            
            showProgress(80);
            
            // Simulate embeddings (in real implementation, would use actual embeddings)
            embeddings = chunks.map(() => Array(384).fill(0).map(() => Math.random()));
            
            showProgress(90);
            
            // Update stats
            document.getElementById('messageCount').textContent = cleanedMessages.length.toLocaleString();
            document.getElementById('chunkCount').textContent = chunks.length.toLocaleString();
            document.getElementById('topicCount').textContent = Math.min(8, Math.ceil(chunks.length / 10));
            
            processedData = {
                messages: cleanedMessages,
                chunks: chunks,
                embeddings: embeddings
            };
        }
        
        function extractText(text) {
            if (typeof text === 'string') {
                return text.trim();
            } else if (Array.isArray(text)) {
                return text.map(item => {
                    if (typeof item === 'string') return item;
                    if (item && item.text) return item.text;
                    return '';
                }).join('').trim();
            }
            return String(text || '').trim();
        }
        
        function isOnlyEmoji(text) {
            const emojiRegex = /^[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F1E0}-\u{1F1FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]+$/u;
            return emojiRegex.test(text) || ['üëç', 'üôè', '‚ù§Ô∏è', 'üòÇ', 'üëå'].includes(text);
        }
        
        function createChunks(messages) {
            const chunks = [];
            const chunkSize = 1000; // tokens approximation
            const overlap = 100;
            
            let currentChunk = [];
            let currentLength = 0;
            
            for (let i = 0; i < messages.length; i++) {
                const msg = messages[i];
                const msgLength = msg.text.length; // Simple approximation
                
                if (currentLength + msgLength > chunkSize && currentChunk.length > 0) {
                    // Save current chunk
                    chunks.push({
                        text: currentChunk.map(m => m.text).join('\\n'),
                        messages: [...currentChunk],
                        startIndex: currentChunk[0].index,
                        endIndex: currentChunk[currentChunk.length - 1].index,
                        earliestDate: currentChunk[0].date
                    });
                    
                    // Keep overlap
                    const overlapSize = Math.min(overlap, currentChunk.length);
                    currentChunk = currentChunk.slice(-overlapSize);
                    currentLength = currentChunk.reduce((sum, m) => sum + m.text.length, 0);
                }
                
                msg.index = i;
                currentChunk.push(msg);
                currentLength += msgLength;
            }
            
            // Add final chunk
            if (currentChunk.length > 0) {
                chunks.push({
                    text: currentChunk.map(m => m.text).join('\\n'),
                    messages: [...currentChunk],
                    startIndex: currentChunk[0].index,
                    endIndex: currentChunk[currentChunk.length - 1].index,
                    earliestDate: currentChunk[0].date
                });
            }
            
            return chunks;
        }
        
        function showProgress(percent) {
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            
            if (percent > 0) {
                progressBar.style.display = 'block';
                progressFill.style.width = percent + '%';
            } else {
                progressBar.style.display = 'none';
            }
        }
        
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
            status.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            }
        }
        
        function showSearch() {
            document.getElementById('searchSection').style.display = 'block';
            document.getElementById('searchInput').focus();
        }
        
        function handleSearchKeyPress(event) {
            if (event.key === 'Enter') {
                performSearch();
            }
        }
        
        function performSearch() {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) return;
            
            if (!processedData) {
                showStatus('–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏ –æ–±—Ä–∞–±–æ—Ç–∞–π—Ç–µ —Ñ–∞–π–ª', 'error');
                return;
            }
            
            const results = searchChunks(query);
            displaySearchResults(results, query);
        }
        
        function searchChunks(query) {
            // Simple text-based search for demo
            const queryLower = query.toLowerCase();
            const results = [];
            
            for (let i = 0; i < chunks.length; i++) {
                const chunk = chunks[i];
                const textLower = chunk.text.toLowerCase();
                
                // Calculate relevance score
                let score = 0;
                const queryWords = queryLower.split(/\\s+/);
                
                queryWords.forEach(word => {
                    const matches = (textLower.match(new RegExp(word, 'g')) || []).length;
                    score += matches;
                });
                
                if (score > 0) {
                    results.push({
                        chunk: chunk,
                        score: score
                    });
                }
            }
            
            // Sort by relevance
            results.sort((a, b) => b.score - a.score);
            
            return results.slice(0, 5); // Top 5 results
        }
        
        function displaySearchResults(results, query) {
            const resultsContainer = document.getElementById('searchResults');
            
            if (results.length === 0) {
                resultsContainer.innerHTML = '<div class="result-item">–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ –∑–∞–ø—Ä–æ—Å—É "' + query + '"</div>';
                return;
            }
            
            let html = '<h3>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –¥–ª—è "' + query + '":</h3>';
            
            results.forEach((result, index) => {
                const chunk = result.chunk;
                const preview = chunk.text.substring(0, 300) + (chunk.text.length > 300 ? '...' : '');
                
                html += `
                    <div class="result-item">
                        <div class="result-date">üìÖ ${chunk.earliestDate} | –†–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç—å: ${result.score}</div>
                        <div class="result-text">${highlightQuery(preview, query)}</div>
                    </div>
                `;
            });
            
            resultsContainer.innerHTML = html;
        }
        
        function highlightQuery(text, query) {
            const queryWords = query.split(/\\s+/);
            let highlightedText = text;
            
            queryWords.forEach(word => {
                const regex = new RegExp(`(${word})`, 'gi');
                highlightedText = highlightedText.replace(regex, '<mark>$1</mark>');
            });
            
            return highlightedText;
        }
        
        async function generateGuide() {
            if (!processedData) {
                showStatus('–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏ –æ–±—Ä–∞–±–æ—Ç–∞–π—Ç–µ —Ñ–∞–π–ª', 'error');
                return;
            }
            
            showStatus('–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≥–∞–π–¥–∞...', 'processing');
            
            // Simulate guide generation
            await sleep(2000);
            
            const guide = createSimpleGuide();
            displayGuide(guide);
            
            showStatus('‚úÖ –ì–∞–π–¥ —Å–æ–∑–¥–∞–Ω!', 'success');
        }
        
        function createSimpleGuide() {
            const topics = extractTopics();
            let guide = '<h2>üìñ –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥–∞–π–¥ –ø–æ —á–∞—Ç—É</h2>\\n\\n';
            
            guide += `<p><strong>–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ:</strong> ${processedData.messages.length} —Å–æ–æ–±—â–µ–Ω–∏–π</p>\\n`;
            guide += `<p><strong>–°–æ–∑–¥–∞–Ω–æ –±–ª–æ–∫–æ–≤:</strong> ${chunks.length}</p>\\n`;
            guide += `<p><strong>–û—Å–Ω–æ–≤–Ω—ã–µ —Ç–µ–º—ã:</strong></p>\\n\\n`;
            
            topics.forEach((topic, index) => {
                guide += `<h3>${index + 1}. ${topic.name}</h3>\\n`;
                guide += `<p>–ù–∞–π–¥–µ–Ω–æ ${topic.chunks.length} —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –æ–±—Å—É–∂–¥–µ–Ω–∏–π</p>\\n`;
                guide += `<p><em>–ü—Ä–∏–º–µ—Ä:</em> "${topic.example}"</p>\\n\\n`;
            });
            
            return guide;
        }
        
        function extractTopics() {
            // Simple topic extraction based on keywords
            const topics = [
                { name: '–¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç –∏ –ª–æ–≥–∏—Å—Ç–∏–∫–∞', keywords: ['—Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç', '–º–∞—à–∏–Ω–∞', '–ø–æ–µ–∑–¥', '—Å–∞–º–æ–ª–µ—Ç', '–±–∏–ª–µ—Ç'] },
                { name: '–ñ–∏–ª—å–µ –∏ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å', keywords: ['–∫–≤–∞—Ä—Ç–∏—Ä–∞', '–¥–æ–º', '–∞—Ä–µ–Ω–¥–∞', '–ø–æ–∫—É–ø–∫–∞', '—Ä–µ–º–æ–Ω—Ç'] },
                { name: '–†–∞–±–æ—Ç–∞ –∏ –∫–∞—Ä—å–µ—Ä–∞', keywords: ['—Ä–∞–±–æ—Ç–∞', '–∫–∞—Ä—å–µ—Ä–∞', '–∑–∞—Ä–ø–ª–∞—Ç–∞', '—Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–µ'] },
                { name: '–§–∏–Ω–∞–Ω—Å—ã –∏ –ø–æ–∫—É–ø–∫–∏', keywords: ['–¥–µ–Ω—å–≥–∏', '–ø–æ–∫—É–ø–∫–∞', '—Ü–µ–Ω–∞', '–±–∞–Ω–∫', '–∫–∞—Ä—Ç–∞'] },
                { name: '–†–∞–∑–≤–ª–µ—á–µ–Ω–∏—è', keywords: ['–∫–∏–Ω–æ', '—Ä–µ—Å—Ç–æ—Ä–∞–Ω', '–æ—Ç–¥—ã—Ö', '—Å–ø–æ—Ä—Ç', '–∏–≥—Ä–∞'] }
            ];
            
            const result = [];
            
            topics.forEach(topic => {
                const relatedChunks = chunks.filter(chunk => {
                    const text = chunk.text.toLowerCase();
                    return topic.keywords.some(keyword => text.includes(keyword));
                });
                
                if (relatedChunks.length > 0) {
                    result.push({
                        name: topic.name,
                        chunks: relatedChunks,
                        example: relatedChunks[0].text.substring(0, 100) + '...'
                    });
                }
            });
            
            return result;
        }
        
        function displayGuide(guide) {
            const resultsContainer = document.getElementById('searchResults');
            resultsContainer.innerHTML = '<div class="result-item">' + guide + '</div>';
            document.getElementById('searchSection').style.display = 'block';
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>
